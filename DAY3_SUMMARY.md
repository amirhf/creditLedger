# Day 3 Implementation Summary

## ✅ Completed: Accounts Service & Posting-Orchestrator

**Date**: 2025-10-10  
**Status**: FULLY IMPLEMENTED & TESTED

---

## What Was Built

### 1. Accounts Service (Port 7101)

**Purpose**: Manage account creation with transactional outbox pattern

**Key Components**:
- ✅ Database schema with accounts + outbox tables
- ✅ Domain validation (3-letter currency codes, status enum)
- ✅ HTTP handler: `POST /v1/accounts`
- ✅ Transactional outbox for `AccountCreated` events
- ✅ Background relay worker publishing to Kafka
- ✅ Graceful shutdown with signal handling

**API Endpoint**:
```http
POST /v1/accounts
Content-Type: application/json

{
  "currency": "USD"
}

Response: 201 Created
{
  "account_id": "uuid",
  "currency": "USD",
  "status": "ACTIVE"
}
```

**Events Emitted**:
- `AccountCreated` → Topic: `ledger.account.v1`

---

### 2. Posting-Orchestrator Service (Port 7103)

**Purpose**: Coordinate transfers with idempotency and event-driven orchestration

**Key Components**:
- ✅ Database schema with transfers + outbox tables
- ✅ Redis-based idempotency guard (SETNX with TTL)
- ✅ Domain validation (positive amounts, different accounts)
- ✅ HTTP handler: `POST /v1/transfers`
- ✅ Transfer orchestration:
  1. Check idempotency (Redis + DB)
  2. Create transfer record (INITIATED)
  3. Emit TransferInitiated event
  4. Call ledger service to create journal entry
  5. Update transfer status (COMPLETED/FAILED)
  6. Emit TransferCompleted/Failed event
- ✅ HTTP client for ledger service calls
- ✅ Background relay worker for event publishing
- ✅ Graceful shutdown

**API Endpoint**:
```http
POST /v1/transfers
Content-Type: application/json

{
  "from_account_id": "uuid",
  "to_account_id": "uuid",
  "amount_minor": 1000,
  "currency": "USD",
  "idempotency_key": "unique-key"
}

Response: 201 Created
{
  "transfer_id": "uuid",
  "status": "COMPLETED",
  "entry_id": "uuid"
}
```

**Events Emitted**:
- `TransferInitiated` → Topic: `ledger.transfer.v1`
- `TransferCompleted` → Topic: `ledger.transfer.v1`
- `TransferFailed` → Topic: `ledger.transfer.v1`

---

## Architecture Patterns Implemented

### 1. Transactional Outbox Pattern
- Domain write + event creation in single database transaction
- Background relay worker polls outbox and publishes to Kafka
- `FOR UPDATE SKIP LOCKED` for concurrent safety
- At-least-once delivery guarantee

### 2. Idempotency
- **Redis Layer**: Fast duplicate detection with SETNX (5-minute TTL)
- **Database Layer**: Unique constraint on idempotency_key
- Returns original result for duplicate requests

### 3. Event-Driven Architecture
- All state changes emit events with metadata
- Events include: event_id, aggregate_id, aggregate_type, schema
- Enables event sourcing and CQRS patterns

### 4. Saga-like Orchestration
- Orchestrator coordinates multi-service operations
- Emits lifecycle events (Initiated, Completed, Failed)
- Compensating actions on failure (TransferFailed event)

### 5. Domain-Driven Design
- Clear domain models with validation
- ValidationError with field-level messages
- Factory methods (NewAccount, NewTransfer)

---

## File Structure

```
services/accounts/
├── cmd/accounts/main.go              # Service entry point
├── internal/
│   ├── domain/account.go             # Domain logic & validation
│   ├── http/http.go                  # HTTP handlers
│   ├── outbox/
│   │   ├── publisher.go              # Kafka publisher
│   │   └── relay.go                  # Outbox relay worker
│   └── store/
│       ├── migrations/0001_init.sql  # Database schema
│       ├── queries.sql               # SQL queries
│       ├── queries.sql.go            # Generated by sqlc
│       ├── models.go                 # Generated by sqlc
│       └── sqlc.yaml                 # sqlc configuration
└── go.mod

services/posting-orchestrator/
├── cmd/orchestrator/main.go          # Service entry point
├── internal/
│   ├── domain/transfer.go            # Domain logic & validation
│   ├── http/handler.go               # HTTP handlers
│   ├── idem/redis.go                 # Idempotency guard
│   ├── outbox/
│   │   ├── publisher.go              # Kafka publisher
│   │   └── relay.go                  # Outbox relay worker
│   └── store/
│       ├── migrations/0001_init.sql  # Database schema
│       ├── queries.sql               # SQL queries
│       ├── queries.sql.go            # Generated by sqlc
│       ├── models.go                 # Generated by sqlc
│       └── sqlc.yaml                 # sqlc configuration
└── go.mod

test_day3.ps1                         # PowerShell test script
DAY3_SETUP.md                         # Setup & testing guide
```

---

## Testing

### Build Verification
```powershell
# Accounts service
cd services/accounts
go build ./cmd/accounts
# ✓ Compiles successfully

# Orchestrator service
cd services/posting-orchestrator
go build ./cmd/orchestrator
# ✓ Compiles successfully
```

### Test Script
```powershell
.\test_day3.ps1
```

**Tests**:
1. ✅ Create Account A (USD)
2. ✅ Create Account B (USD)
3. ✅ Transfer from A to B (1000 cents)
4. ✅ Idempotency test (retry same transfer)
5. ✅ Validation test (invalid currency)
6. ✅ Validation test (same account transfer)

---

## Key Achievements

### Production-Ready Features
- ✅ Graceful shutdown (signal handling, context cancellation)
- ✅ Health checks (`/healthz` endpoints)
- ✅ Prometheus metrics (`/metrics` endpoints)
- ✅ Structured logging with context
- ✅ Error handling with rollback
- ✅ Connection pooling and health checks

### Reliability Patterns
- ✅ Transactional outbox (at-least-once delivery)
- ✅ Idempotency (exactly-once effect)
- ✅ Concurrent safety (FOR UPDATE SKIP LOCKED)
- ✅ Retry logic in relay workers
- ✅ Event metadata for deduplication

### Code Quality
- ✅ Type-safe database queries (sqlc)
- ✅ Domain validation with clear errors
- ✅ Separation of concerns (domain, http, store, outbox)
- ✅ Dependency injection
- ✅ No hardcoded values (environment variables)

---

## Integration with Day 2 (Ledger Service)

The orchestrator service integrates with the ledger service from Day 2:

```
Orchestrator (Day 3)
    │
    └─> HTTP POST /v1/entries
            │
            └─> Ledger Service (Day 2)
                    │
                    ├─> Validates double-entry
                    ├─> Writes journal_entries + journal_lines
                    ├─> Writes outbox event
                    └─> Returns entry_id
```

**Flow**:
1. Orchestrator creates transfer record (INITIATED)
2. Orchestrator calls ledger service with DR/CR lines
3. Ledger validates and creates journal entry
4. Ledger emits EntryPosted event
5. Orchestrator marks transfer COMPLETED
6. Orchestrator emits TransferCompleted event

---

## Environment Variables

### Accounts Service
```powershell
$env:DATABASE_URL="postgres://accounts:accountspw@localhost:5433/accounts?sslmode=disable"
$env:KAFKA_BROKERS="localhost:19092"
$env:PORT="7101"
```

### Orchestrator Service
```powershell
$env:DATABASE_URL="postgres://orchestrator:orchestratorpw@localhost:5435/orchestrator?sslmode=disable"
$env:REDIS_URL="redis://localhost:6379"
$env:KAFKA_BROKERS="localhost:19092"
$env:LEDGER_URL="http://localhost:7102"
$env:PORT="7103"
```

---

## Kafka Topics

| Topic | Events | Producer |
|-------|--------|----------|
| `ledger.account.v1` | AccountCreated | Accounts Service |
| `ledger.entry.v1` | EntryPosted | Ledger Service |
| `ledger.transfer.v1` | TransferInitiated, TransferCompleted, TransferFailed | Orchestrator Service |

---

## Database Schemas

### Accounts Database (Port 5433)
- `accounts` - Account records
- `outbox` - Event outbox

### Orchestrator Database (Port 5435)
- `transfers` - Transfer records with idempotency_key
- `outbox` - Event outbox

### Ledger Database (Port 5434) - From Day 2
- `journal_entries` - Journal entry headers
- `journal_lines` - Journal entry lines (DR/CR)
- `outbox` - Event outbox

---

## Next Steps (Day 4)

### Read-Model Service
- [ ] Consume `EntryPosted` events from Kafka
- [ ] Maintain `balances` table (UPSERT on account_id)
- [ ] Maintain `statements` table (append-only)
- [ ] Implement `GET /v1/accounts/:id/balance`
- [ ] Implement `GET /v1/accounts/:id/statements`
- [ ] Event deduplication via event_id

### Gateway Service
- [ ] Unified REST API for external clients
- [ ] Request validation with Zod schemas
- [ ] Route to internal services:
  - POST /accounts → accounts service
  - POST /transfers → orchestrator service
  - GET /accounts/:id/balance → read-model service
  - GET /accounts/:id/statements → read-model service

---

## Lessons Learned

1. **Local Module Dependencies**: Use `replace` directive in go.mod for proto module
2. **Redis Idempotency**: SETNX provides fast duplicate detection; DB provides audit trail
3. **Outbox Relay**: FOR UPDATE SKIP LOCKED enables horizontal scaling
4. **Error Handling**: Always emit failure events for observability
5. **Validation**: Domain-level validation prevents invalid state
6. **HTTP Clients**: Set timeouts to prevent hanging requests
7. **Graceful Shutdown**: Context cancellation + server shutdown prevents data loss

---

## Performance Considerations

- Outbox relay polls every 100ms (configurable)
- Batch size of 10 events per cycle (configurable)
- Redis TTL of 5 minutes for idempotency keys
- HTTP client timeout of 10 seconds
- Database connection pooling enabled by default

---

## Monitoring & Observability

All services expose:
- Health checks: `GET /healthz`
- Prometheus metrics: `GET /metrics`
- Structured logs with context (transfer_id, account_id, etc.)

Ready for Day 5 observability work:
- OpenTelemetry tracing
- Custom Prometheus metrics
- Grafana dashboards

---

## Status: ✅ READY FOR DAY 4

All Day 3 objectives completed:
- ✅ Accounts service implemented and tested
- ✅ Orchestrator service implemented and tested
- ✅ Idempotency working (Redis + DB)
- ✅ Transactional outbox pattern in all services
- ✅ Event-driven architecture established
- ✅ Integration with Day 2 ledger service verified
- ✅ Documentation complete
- ✅ Test scripts provided

The system now supports the complete transfer flow from account creation to journal entry posting with full event traceability.
